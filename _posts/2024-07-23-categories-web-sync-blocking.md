---
title: "동기 VS 비동기, 블로킹 VS 논블로킹"
excerpt: "이젠 헷갈리지말자"

categories:
  - "WEB"
tags:
  - ['async', '비동기', '동기']

permalink: /categories/web/sync-blocking

toc: true
toc_sticky: true

date: 2024-07-23
last_modified_at: 2024-07-23
---
# 동기 VS 비동기, 블로킹 VS 논블로킹  


## 동기 VS 비동기
동기와 비동기의 차이는 Calle(호출되는 쪽)의 **작업 완료 확인의 차이**   
Callback의 유무의 차이? 라고 생각하면 이해가 더 쉬울지도?

### 1) 동기(Sync)
- Caller(호출하는 쪽)가 Calle(호출되는 쪽)을 실행한 다음에, Calle의 리턴값을 계속 확인하는 것   

### 2) 비동기(Async)
- Caller가 Calle의 작업 완료 확인을 하지 않는다
- 확인을 하는 대신 Caller는 Callback 함수를 전달하고, Calle가 해당 함수를 실행 시키도록 한다   

<br/>

## 블로킹 VS 논블로킹
블로킹과 논블로킹은 Caller가 Calle에게 **제어권을 주는 지를 파악**   
제어권 없으면 계속 대기타야한다

### 1) 블로킹(Blocking)
- Calle에게 로직 제어권을 전달한다. Calle의 작업이 종료될때까지 Caller는 다른 작업 불가

### 2) 논블로킹(Non-Blocking)
- Calle가 자신의 작업이 완료가 아니여도 제어권을 Caller에게 넘겨준다   

---

# 동기 VS 비동기, 블로킹 VS 논블로킹의 조합
![img.png](/assets/images/posts_img/dev/web/sync_blocking/img.png)

## 1) 동기 + 블로킹

1. 동기: Caller인 함수 A는 B의 리턴값을 확인
2. 블로킹: Caller인 함수 A는 Calle인 함수 B에게 제어권을 넘기고 대기

- 함수 A는 함수 B에게 요청을 하고, 계속 대기

## 2) 동기 + 논블로킹

1. 동기: Caller인 함수 A는 B의 리턴값을 확인
2. 논블로킹: Caller인 함수 A는 Calle인 함수 B에게 제어권을 바로 받고 그대로 실행

- 함수 A는 함수 B에게 요청을 하고, 자기 할거 가능.
- 대신에 Callback이 없으니 계속 확인을 해야한다

## 3) 비동기 + 블로킹

1. 비동기: Caller인 함수 A는 B의 리턴값을 확인하지 않는다
2. 블로킹: Caller인 함수 A는 Calle인 함수 B에게 제어권을 넘기고 대기

- 함수 A는 리턴값을 확인하지 않는다고 해도, 제어권이 없기에 대기
- 사실상 동기-블로킹과 동일하다

## 4) 비동기 + 논블로킹

1. 비동기: Caller인 함수 A는 B의 리턴값을 확인하지 않는다
2. 논블로킹: Caller인 함수 A는 Calle인 함수 B에게 제어권을 바로 받고 그대로 실행

- 함수 A는 함수 B에게 요청을 하고 자기 할 것 그대로 진행
- 함수 B는 요청받은 일을 완료한 다음에 A에게 전달받은 Callback 함수 실행
- 함수 A는 완료 여부 신경쓰지 않고, Callback 실행하면 된다

# Review
- 동기-비동기, 블로킹-논블로킹의 관계가 얼핏보면 똑같아보이는데 다르다
- 두 관계의 차이점을 명확히 알아야한다고 생각한다
- 근데 항상 본 다음에 이해하고, 시간 지난 다음에 까먹고, 또 본 다음에 이해하고 까먹고의 반복...
- 그냥 블로그에 따로 정리하는게 나을 것 같아서 기록한다...
- 나중에 까먹더라도 "진짜 알아! 적어놓기까지 했다니깐?"이라고 변명이라도 하게 ㅋㅋㅋ
